using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using DotLiquid;
using Frends.Radon.LiquidExtensions;
using Frends.Radon.TemplateDrops;

[assembly: InternalsVisibleTo("Frends.Radon.Tests")]
namespace Frends.Radon
{
    public interface IHtmlReportGenerator
    {
        string CreateHtmlReport();
        string CreateSubject();
    }

    public class HtmlReportGenerator : IHtmlReportGenerator
    {
        private readonly IList<LogEventDrop> _events;
        private readonly IFilterConfiguration _filterConfig;
        private readonly IEmailConfiguration _emailConfig;
        private readonly Hash _contextHash;
        private const string DefaultTemplate = @"
{% assign bgColor1 = '#f1f1f1' %}
{% assign bgColor2 = '#f2f2f2' %}

{{ count }}{% if count >= config.max_messages %} latest{% endif %} previously unreported events from the {{ event_log_name }} log from {{ start_time }} to {{ current_time }} on the machine {{ machine_name }}
<table border='0' cellspacing='2px' cellpadding='2'>
    <thead>
        <tr bgcolor='{{ bgColor2 }}'>
            <th>Level</th>
            <th>Date and Time</th>
            <th>Source</th>
            <th>Event ID</th>
            <th>Category</th>
            <th>Message</th>
        </tr>
    </thead>
    <tbody>
    {% for event in events %}
        <tr bgcolor='{% cycle '#ffffff', bgcolor1 %}'>
            <td>{{ event.entry_type }}</td>
            <td>{{ event.time_generated }}</td>
            <td>{{ event.source }}</td>
            <td>{{ event.event_id }}</td>
            <td>{{ event.category }}</td>
            <td>{{ event.message | escape }}</td>
        </tr>
    {% endfor %}    
    </tbody>
</table>
<p>Filter used: <pre>{{ config.filter_string }}</pre></p>
<hr />
<p>This report was generated by FRENDS Radon ( <a href='http://www.frends.com'>Frends Technology</a> )</p>
";

        public HtmlReportGenerator(IEnumerable<LogEvent> events, IFilterConfiguration filterConfiguration, IEmailConfiguration emailConfiguration)
        {
            _events = events==null ? new List<LogEventDrop>() : events.Select(l => new LogEventDrop(l)).ToList();
            _filterConfig = filterConfiguration;
            _emailConfig = emailConfiguration;
            _contextHash = CreateContextHash(_filterConfig, _events);

            Template.RegisterFilter(typeof(FilterExtensions));
        }

        public string CreateHtmlReport()
        {
            var templateString = String.IsNullOrEmpty(_emailConfig.TemplateFile)
                                     ? DefaultTemplate
                                     : File.ReadAllText(_emailConfig.TemplateFile);

            var template = Template.Parse(templateString);

            return template.Render(_contextHash);
        }

        public string CreateSubject()
        {
            return Template.Parse(_emailConfig.Subject).Render(_contextHash);
        }

        internal static Hash CreateContextHash(IFilterConfiguration config, IList<LogEventDrop> events)
        {
            var currentTime = DateTime.Now;

            var startTime = currentTime.Subtract(config.TimeLimit).ToString("g");
            var sourceMachineString = (String.IsNullOrEmpty(config.RemoteMachine) ? Environment.MachineName : config.RemoteMachine);
            var eventLogName = String.IsNullOrEmpty(config.EventLogName) ? "Application" : config.EventLogName;

            return Hash.FromAnonymousObject(new 
            { 
                events,
                count = events.Count(),
                config = new FilterConfigurationDrop(config), 
                start_time = startTime, 
                current_time = currentTime.ToString("g"), 
                machine_name = sourceMachineString, 
                event_log_name = eventLogName 
            });
        }
    }
}